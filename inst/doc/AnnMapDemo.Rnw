%\VignetteIndexEntry{AnnMap API Demo}
%\VignetteDepends{hgu95av2db}
%\VignetteKeywords{annotation, database}
%\VignettePackage{AnnotationDbi}
\documentclass[11pt]{article}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}


\title{AnnMap API Demo}
\author{Herve Pages, Nianhua Li, and Seth Falcon}

\begin{document}

\maketitle

\section{Introduction}

The \Rpackage{AnnotationDbi} package provides an interface to
SQLite-based annotation data packages.  Each SQLite-based annotation
package (identified by a ``db'' suffix in the package name) contains a
number of \Rclass{AnnMap} objects in place of the \Rclass{environment}
objects found in the old-style environment-based annotation packages.
The API provided by \Rpackage{AnnotationDbi} allows you to treat the
\Rclass{AnnMap} objects like environments.  For example, the functions
\verb+[[+, \Rfunction{get}, \Rfunction{mget}, and \Rfunction{ls} all
behave the same as with the old-style packages.  In addition, we are
experimenting with some extensions to \Rfunction{as.data.frame} and
\Rfunction{as.list} that provide some additional flexibility in
accessing the annotation data.

<<setup, results=hide>>=
library("hgu95av2db")
@ 

<<basic>>=
ls(2)
x <- hgu95av2PATH
x
as.data.frame(x)[1:6, ]
as.data.frame(x, "40781_at")[1:10, ]

as.list(x, "40781_at")   # equivalent to mget("40781_at", x)
@ 

Pick up some probeset ids:

<<as.data.frame>>=
pbids <- names(x)[1:4]   # names() is the same as ls()
as.data.frame(x, pbids)[1:10, ]
as.list(x, pbids)
@ 

Back to the data frame:

<<as.data.frame2>>=
as.data.frame(x)[1:6, ]
as.data.frame(x, , "00230")[1:10, ]
@ 

too long... With another KEGG id:

<<as.data.frame3>>= 
as.data.frame(x, , "00300")
@ 

This doesn't work (only 2 args to as.list, x and names):

<<notworking, eval=FALSE>>=
as.list(x, , "00300")
as.list(x, "00300")
@ 

You must do this instead:

<<thisworks>>=
as.list(revmap(x), "00300")
@ 

The reverse map:

<<revmap1>>=
revmap(x)
x
@ 

In the case of the PATH map, we don't need to use revmap(x)
because hgu95av2db already provides the PATH2PROBE map:

<<revmap2>>=
revx <- hgu95av2PATH2PROBE   # except for the name, this is exactly revmap(x)
revx2 <- revmap(x, mapName="PATH2PROBE")
revx2
identical(revx, revx2)

as.list(revx, "00300")
@ 

Note that the order of the cols returned by as.data.frame() does
not depend on the orientation of the map ("unoriented method"):

<<unorientedMethod>>=
as.data.frame(x)[1:6, ]
as.data.frame(revx)[1:6, ]
@ 

NB: the left names are always on the left (1st col), the right names
always in the 2nd col

There can be more than 2 columns in the returned data frame:

  3 cols:
<<threecols>>=
as.data.frame(hgu95av2PFAM)[1:6, ]  # the right values are tagged
as.list(hgu95av2PFAM, "1000_at")
@ 
  4 cols:
<<fourcols>>=
as.data.frame(hgu95av2GO)[1:6, ]    
as.list(hgu95av2GO, "1000_at")[[1]][1:2]
@ 

But the right names are ALWAYS in the 2nd col.

For length() and names(), the result does depend on the orientation
("oriented methods"):

<<orientedMethods>>=
length(x)
length(revx)
allProbeSetIds <- names(x)
allKEGGIds <- names(revx)
@ 

There are "unoriented" methods related to these methods:
<<moreUnorientedMethods>>=
junk <- left.names(x)    # same for all maps in hgu95av2db (except pseudo-map
                         # MAPCOUNTS)
left.length(x)           # nb of left names
junk <- right.names(x)   # KEGG ids for PATH/PATH2PROBE maps, GO ids for
                         # GO/GO2PROBE/GO2ALLPROBES maps, etc...
right.length(x)          # nb of right names
@ 

NB: they give the same result for x and revmap(x)

This helps to understand the naming of the as.data.frame args:
<<naming, eval=FALSE>>=
as.data.frame(x, left.names, right.names)
@ 

Using revmap can be very efficient in some use cases:
<<revmapUseCases>>=
x <- hgu95av2CHR
right.names(x)
chroms <- right.names(x)[24:25]
chroms
as.data.frame(x, , chroms)[1:10, ]
@ 

To get this in the classic named-list format:
<<easy>>=
as.list(revmap(x), chroms)
@ 

Compare to what you need to do this with the current envir-based package:

<<hard, eval=FALSE>>=
  library(hgu95av2)
  u <- unlist(as.list(hgu95av2CHR))
  u <- u[u %in% chroms]
  split(names(u), u)
@ 

A last example with cytogenetic locations:
<<cytogenicLoc>>=
x <- hgu95av2MAP
as.data.frame(hgu95av2MAP)[1:6, ]
as.list(revmap(x), "8p22")
@ 

Are the probes in 'pbids' mapped to cytogenetic location "6p21.3"?

<<cytogenetic2>>=
pbids <- c("38912_at", "41654_at", "907_at", "2053_at", "2054_g_at", 
           "40781_at")
as.data.frame(x, pbids, "18q11.2")
@ 

To coerce this map to a named vector:

<<coerce>>=
  pb2cyto <- as.character(x)
  pb2cyto[pbids]
@ 

The coercion of the reverse map works too but issues a warning because
of the duplicated names:

<<hmm>>=
  cyto2pb <- as.character(revmap(x))
@ 

\end{document}
