
as.list
-------
  - add a 'ifnotmapped' arg which indicates which value to attach
    to unmapped names (default would be NULL, not NA!)

mget
----
  - call as.list with 'ifnotmapped=NA' in order to mimic behaviour of
    the current envir-based ann packages
  - implement the 'ifnotfound' arg (is currently ignored, mget currently
    returns an error when 'x' is not found).

Add a 'colnames' method (requested by various people) to the low-level API.
Conceptual definition (for AnnMap object x):
  colnames(x) :== colnames(as.data.frame(x))
Of course, it has to be implemented in a smartest way...

Nolwenn also suggested that as.list(x) return a list of named vectors
when x is a ReverseAtomicMap with tags.


Some cleaning
-------------
  - remove all "Annot*" classes (+ "functionORNULL") defined in
    R/AllClasses.R + methods defined for those classes


The 'join' slot and "pluggable" maps
------------------------------------
The slot 'join' for AnnMap objects is not flexible enough. Its names
is not good neither because it doesn't clearly indicates that it
must always go in the "reverse" order. Example:
  if the path to go from 'x@leftTable' to 'x@rightTable' is to go thru
  table2 (using colL2), followed by table3 (using col23),
  followed by 'x@rightTable' (using col3R) then 'x@join' must be
    INNER JOIN table3 USING (col3R)
    INNER JOIN table2 USING (col23)
    INNER JOIN leftTable USING (colL2)
Another ugly (and error-prone) requirement is that rightTable must be omitted
but not leftTable in the 'join' slot.
A much better way to store the join information would be to have a 'L2Rjoin'
slot containing the list of cols and tables you need to go thru to go from
the leftTable to the rightTable. For the above example, this gives a
character vector containing 5 strings:
  colL2 table2 col23 table3 col3R
Note that:
  - col names and table names are alternate
  - first and last values must be a col name
  - the length of the 'L2Rjoin' slot is always odd
Advantages:
  - it leaves out SQL syntactic details
  - it's clearly easier to read/maintain and then less error-prone
  - it allows easy SQL join generation and with a lot of control like the
    possibility to choose between the direct or reverse join, an INNER or
    LEFT join, etc...
  - it will even allow to easily "plug" 2 maps together: if x1@rightTable
    is the same as x2@leftTable, then c(x1, x2) is a map that goes from
    x1@leftTable.x1@leftCol to x2@rightTable.x2@rightCol. And the 'L2Rjoin'
    slot for 'c(x1, x2)' is c(x1@L2Rjoin, x1@rightTable, x2@L2Rjoin).
    Of course, only maps that belong to the same package will be pluggable
    this way (e.g. hgu95av2PATH2PROBE and hgu95av2ACCNUM, x1 is a reverse
    map and x2 a direct map). So not only x1@rightTable and x2@leftTable
    must be the same, but also the SQL connection ('con' slot).


